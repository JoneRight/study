# 1、css 不会阻塞 Dom 加载

\*答： ···

<header>
    <script src="/js/logDiv.js"></script>
    <link rel="stylesheet" href="/css/sleep3000-common.css">
</header>
···
这样的话，会先执行js，首先在控制台打印出来需要打印的内容
然后再执行css，也就是3s之后变化的样子，这也就是说不会影响Dom的加载
浏览器解析DOM，生成Dom Tree，然后结合Css生成Css Tree。

但是如下代码的话，那就另当别论了 ···

<header>
    <link rel="stylesheet" href="/css/sleep3000-common.css">
    <script src="/js/logDiv.js"></script>
</header>
···
答案是浏览器会转圈圈三秒，但此过程中不会打印任何东西，之后呈现出一个浅蓝色的div，再打印出null。结果好像是CSS不单阻塞了页面渲染，还阻塞了DOM 的解析啊！
稍等，在你打算掀桌子疯狂吐槽我之前，请先思考一下是什么阻塞了DOM 的解析，刚才已经证明了CSS是不会阻塞的，那么阻塞了页面解析其实是JS！
但明明JS的代码如此简单，肯定不会阻塞这么久，那就是JS在等待CSS的下载，这是为什么呢？
仔细思考一下，其实这样做是有道理的，如果脚本的内容是获取元素的样式，宽高等CSS控制的属性，浏览器是需要计算的，也就是依赖于CSS。
浏览器也无法感知脚本内容到底是什么，为避免样式获取，因而只好等前面所有的样式下载完后，
再执行JS。因而造成了之前例子的情况。
所以，看官大人明白为何
script与link同时在头部的话，script在上可能会更好了么？之所以是可能，是因为如果link的内容下载更快的话，是没影响的，但反过来的话，JS就要等待了，然而这些等待的时间是完全不必要的。

# 2、浏览器渲染页面的原理及流程

1、先生成 dom tree，再生成 css tree 最后生成 render tree，再加载 js 2、看是重绘还是重拍

// 从扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这 5 张牌是不是连续的。2 ～ 10 为数字本身，A 为 1，J 为 11，Q 为 12，K 为 13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。 // 示例 1: // 输入: [1,2,3,4,5] // 输出: True

// 示例 2: // 输入: [0,0,1,2,5] // 输出: True

// 限制： // 数组长度为 5 // 数组的数取值为 [0, 13] .
